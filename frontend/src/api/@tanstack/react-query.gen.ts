// This file is auto-generated by @hey-api/openapi-ts

import type { OptionsLegacyParser } from '@hey-api/client-axios';
import { queryOptions, type UseMutationOptions, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { RegisterChargeStationData, RegisterChargeStationError, RegisterChargeStationResponse, ReconfigureChargeStationData, ReconfigureChargeStationError, ReconfigureChargeStationResponse, InstallChargeStationCertificatesData, InstallChargeStationCertificatesError, InstallChargeStationCertificatesResponse, LookupChargeStationAuthData, TriggerChargeStationData, TriggerChargeStationError, TriggerChargeStationResponse, SetTokenData, SetTokenError, SetTokenResponse, ListTokensData, ListTokensError, ListTokensResponse, LookupTokenData, UploadCertificateData, UploadCertificateError, UploadCertificateResponse, LookupCertificateData, DeleteCertificateData, DeleteCertificateError, DeleteCertificateResponse, RegisterPartyData, RegisterPartyError, RegisterPartyResponse, RegisterLocationData, RegisterLocationError, RegisterLocationResponse } from '../types.gen';
import type { AxiosError } from 'axios';
import { client, registerChargeStation, reconfigureChargeStation, installChargeStationCertificates, lookupChargeStationAuth, triggerChargeStation, setToken, listTokens, lookupToken, uploadCertificate, lookupCertificate, deleteCertificate, registerParty, registerLocation } from '../sdk.gen';

type QueryKey<TOptions extends OptionsLegacyParser> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends OptionsLegacyParser>(id: string, options?: TOptions, infinite?: boolean): QueryKey<TOptions>[0] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: (options?.client ?? client).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return params;
};

export const registerChargeStationQueryKey = (options: OptionsLegacyParser<RegisterChargeStationData>) => [
    createQueryKey('registerChargeStation', options)
];

export const registerChargeStationOptions = (options: OptionsLegacyParser<RegisterChargeStationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await registerChargeStation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: registerChargeStationQueryKey(options)
    });
};

export const registerChargeStationMutation = (options?: Partial<OptionsLegacyParser<RegisterChargeStationData>>) => {
    const mutationOptions: UseMutationOptions<RegisterChargeStationResponse, AxiosError<RegisterChargeStationError>, OptionsLegacyParser<RegisterChargeStationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await registerChargeStation({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const reconfigureChargeStationQueryKey = (options: OptionsLegacyParser<ReconfigureChargeStationData>) => [
    createQueryKey('reconfigureChargeStation', options)
];

export const reconfigureChargeStationOptions = (options: OptionsLegacyParser<ReconfigureChargeStationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await reconfigureChargeStation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: reconfigureChargeStationQueryKey(options)
    });
};

export const reconfigureChargeStationMutation = (options?: Partial<OptionsLegacyParser<ReconfigureChargeStationData>>) => {
    const mutationOptions: UseMutationOptions<ReconfigureChargeStationResponse, AxiosError<ReconfigureChargeStationError>, OptionsLegacyParser<ReconfigureChargeStationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await reconfigureChargeStation({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const installChargeStationCertificatesQueryKey = (options: OptionsLegacyParser<InstallChargeStationCertificatesData>) => [
    createQueryKey('installChargeStationCertificates', options)
];

export const installChargeStationCertificatesOptions = (options: OptionsLegacyParser<InstallChargeStationCertificatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await installChargeStationCertificates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: installChargeStationCertificatesQueryKey(options)
    });
};

export const installChargeStationCertificatesMutation = (options?: Partial<OptionsLegacyParser<InstallChargeStationCertificatesData>>) => {
    const mutationOptions: UseMutationOptions<InstallChargeStationCertificatesResponse, AxiosError<InstallChargeStationCertificatesError>, OptionsLegacyParser<InstallChargeStationCertificatesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await installChargeStationCertificates({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lookupChargeStationAuthQueryKey = (options?: OptionsLegacyParser<LookupChargeStationAuthData>) => [
    createQueryKey('lookupChargeStationAuth', options)
];

export const lookupChargeStationAuthOptions = (options?: OptionsLegacyParser<LookupChargeStationAuthData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lookupChargeStationAuth({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lookupChargeStationAuthQueryKey(options)
    });
};

export const triggerChargeStationQueryKey = (options: OptionsLegacyParser<TriggerChargeStationData>) => [
    createQueryKey('triggerChargeStation', options)
];

export const triggerChargeStationOptions = (options: OptionsLegacyParser<TriggerChargeStationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await triggerChargeStation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: triggerChargeStationQueryKey(options)
    });
};

export const triggerChargeStationMutation = (options?: Partial<OptionsLegacyParser<TriggerChargeStationData>>) => {
    const mutationOptions: UseMutationOptions<TriggerChargeStationResponse, AxiosError<TriggerChargeStationError>, OptionsLegacyParser<TriggerChargeStationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await triggerChargeStation({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const setTokenQueryKey = (options: OptionsLegacyParser<SetTokenData>) => [
    createQueryKey('setToken', options)
];

export const setTokenOptions = (options: OptionsLegacyParser<SetTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await setToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: setTokenQueryKey(options)
    });
};

export const setTokenMutation = (options?: Partial<OptionsLegacyParser<SetTokenData>>) => {
    const mutationOptions: UseMutationOptions<SetTokenResponse, AxiosError<SetTokenError>, OptionsLegacyParser<SetTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await setToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTokensQueryKey = (options?: OptionsLegacyParser<ListTokensData>) => [
    createQueryKey('listTokens', options)
];

export const listTokensOptions = (options?: OptionsLegacyParser<ListTokensData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTokens({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTokensQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<OptionsLegacyParser>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<OptionsLegacyParser>, page: K) => {
    const params = queryKey[0];
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path,
            ...page.path
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query,
            ...page.query
        };
    }
    return params as unknown as typeof page;
};

export const listTokensInfiniteQueryKey = (options?: OptionsLegacyParser<ListTokensData>): QueryKey<OptionsLegacyParser<ListTokensData>> => [
    createQueryKey('listTokens', options, true)
];

export const listTokensInfiniteOptions = (options?: OptionsLegacyParser<ListTokensData>) => {
    return infiniteQueryOptions<ListTokensResponse, AxiosError<ListTokensError>, InfiniteData<ListTokensResponse>, QueryKey<OptionsLegacyParser<ListTokensData>>, number | Pick<QueryKey<OptionsLegacyParser<ListTokensData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<OptionsLegacyParser<ListTokensData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTokens({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTokensInfiniteQueryKey(options)
    });
};

export const lookupTokenQueryKey = (options: OptionsLegacyParser<LookupTokenData>) => [
    createQueryKey('lookupToken', options)
];

export const lookupTokenOptions = (options: OptionsLegacyParser<LookupTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lookupToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lookupTokenQueryKey(options)
    });
};

export const uploadCertificateQueryKey = (options: OptionsLegacyParser<UploadCertificateData>) => [
    createQueryKey('uploadCertificate', options)
];

export const uploadCertificateOptions = (options: OptionsLegacyParser<UploadCertificateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await uploadCertificate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: uploadCertificateQueryKey(options)
    });
};

export const uploadCertificateMutation = (options?: Partial<OptionsLegacyParser<UploadCertificateData>>) => {
    const mutationOptions: UseMutationOptions<UploadCertificateResponse, AxiosError<UploadCertificateError>, OptionsLegacyParser<UploadCertificateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await uploadCertificate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lookupCertificateQueryKey = (options: OptionsLegacyParser<LookupCertificateData>) => [
    createQueryKey('lookupCertificate', options)
];

export const lookupCertificateOptions = (options: OptionsLegacyParser<LookupCertificateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lookupCertificate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lookupCertificateQueryKey(options)
    });
};

export const deleteCertificateMutation = (options?: Partial<OptionsLegacyParser<DeleteCertificateData>>) => {
    const mutationOptions: UseMutationOptions<DeleteCertificateResponse, AxiosError<DeleteCertificateError>, OptionsLegacyParser<DeleteCertificateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCertificate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const registerPartyQueryKey = (options: OptionsLegacyParser<RegisterPartyData>) => [
    createQueryKey('registerParty', options)
];

export const registerPartyOptions = (options: OptionsLegacyParser<RegisterPartyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await registerParty({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: registerPartyQueryKey(options)
    });
};

export const registerPartyMutation = (options?: Partial<OptionsLegacyParser<RegisterPartyData>>) => {
    const mutationOptions: UseMutationOptions<RegisterPartyResponse, AxiosError<RegisterPartyError>, OptionsLegacyParser<RegisterPartyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await registerParty({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const registerLocationQueryKey = (options: OptionsLegacyParser<RegisterLocationData>) => [
    createQueryKey('registerLocation', options)
];

export const registerLocationOptions = (options: OptionsLegacyParser<RegisterLocationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await registerLocation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: registerLocationQueryKey(options)
    });
};

export const registerLocationMutation = (options?: Partial<OptionsLegacyParser<RegisterLocationData>>) => {
    const mutationOptions: UseMutationOptions<RegisterLocationResponse, AxiosError<RegisterLocationError>, OptionsLegacyParser<RegisterLocationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await registerLocation({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};